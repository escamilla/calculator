[ Conway's Game of Life ]

(let initial-grid
  '((0 0 0 1 1 0 0 0)
    (0 0 1 0 0 1 0 0)
    (0 1 0 0 0 0 1 0)
    (1 0 0 0 0 0 0 1)
    (1 0 0 0 0 0 0 1)
    (0 1 0 0 0 0 1 0)
    (0 0 1 0 0 1 0 0)
    (0 0 0 1 1 0 0 0)))

(let print-grid (lambda (grid)
  (sequence
    (let rows (length grid))
    (map
      (range rows)
      (lambda (row) (print (nth grid row)))))))

(let get-neighboring-points (lambda (point)
  (sequence
    (let x (nth point 0))
    (let y (nth point 1))
    (list
      (list (sub x 1) (sub y 1))
      (list (sub x 1) y)
      (list (sub x 1) (add y 1))
      (list x (sub y 1))
      (list x (add y 1))
      (list (add x 1) (sub y 1))
      (list (add x 1) y)
      (list (add x 1) (add y 1))))))

(let get-value-at-point (lambda (grid point)
  (sequence
    (let x (nth point 0))
    (let y (nth point 1))
    (if (and (and (ge x 0) (lt x (length grid)))
             (and (ge y 0) (lt y (length (head grid)))))
      (nth (nth grid x) y)
      0))))

(let get-neighboring-values (lambda (grid point)
  (map
    (get-neighboring-points point)
    (lambda (point) (get-value-at-point grid point)))))

(let compute-new-value (lambda (grid point)
  (sequence
    (let living-neighbors (sum (get-neighboring-values grid point)))
    (if (eq 1 (get-value-at-point grid point))
      (if (or (eq living-neighbors 2) (eq living-neighbors 3))
        1
        0)
      (if (eq living-neighbors 3)
        1
        0)))))

(let generate-next-grid (lambda (grid)
  (sequence
    (let rows (length grid))
    (let cols (length (head grid)))
    (map
      (range rows)
      (lambda (row)
        (map
          (range cols)
          (lambda (col)
            (compute-new-value grid (list row col)))))))))

(let generate-n-grids (lambda (grid count)
  (if (eq 0 count)
    '()
    (sequence
      (print-grid grid)
      (print '())
      (generate-n-grids (generate-next-grid grid) (sub count 1))))))

(generate-n-grids initial-grid 11)
