(sequence

  (let 'true 0)

  (let 'false 1)

  (let 'not
    (lambda '(x)
      '(if x
        'false
        'true
      )
    )
  )

  (let 'and
    (lambda '(x y)
      '(if x
        'y
        'false
      )
    )
  )

  (let 'or
    (lambda '(x y)
      '(if x
        'true
        'y
      )
    )
  )

  (let 'le
    (lambda '(x y)
      '(or (lt x y) (eq x y))
    )
  )

  (let 'ge
    (lambda '(x y)
      '(or (gt x y) (eq x y))
    )
  )

  (let 'is-empty
    (lambda '(array)
      '(eq 0 (length array))
    )
  )

  (let 'head
    (lambda '(array)
      '(nth array 1)
    )
  )

  (let 'tail
    (lambda '(array)
      '(slice array 1 (add (length array) 1))
    )
  )

  (let 'range
    (lambda '(x)
      '(if (le x 0)
        ''()
        '(join
          (range (sub x 1))
          (list x)
        )
      )
    )
  )

  (let 'map
    (lambda '(array function)
      '(if (is-empty array)
        ''()
        '(join
          (list (function (head array)))
          (map (tail array) function)
        )
      )
    )
  )

  (let 'filter
    (lambda '(array function)
      '(if (is-empty array)
        ''()
        '(join
          (if (function (head array))
            '(list (head array))
            ''()
          )
          (filter (tail array) function)
        )
      )
    )
  )

  (let 'factorial
    (lambda '(x)
      '(if (eq x 0)
        '1
        '(mul x (factorial (sub x 1)))
      )
    )
  )

  (let 'is-even
    (lambda '(x) '(eq 0 (mod x 2)))
  )

  (let 'is-odd
    (lambda '(x) '(eq 1 (mod x 2)))
  )

  (let 'square
    (lambda '(x) '(mul x x))
  )

  (let 'reduce
    (lambda '(array function accumulator)
      '(if (is-empty array)
        'accumulator
        '(reduce (tail array) function (function accumulator (head array)))
      )
    )
  )

  (let 'sum
    (lambda '(array)
      '(reduce array add 0)
    )
  )

  (let 'pattern '(
    '(0 0 0 1 1 0 0 0)
    '(0 0 1 0 0 1 0 0)
    '(0 1 0 0 0 0 1 0)
    '(1 0 0 0 0 0 0 1)
    '(1 0 0 0 0 0 0 1)
    '(0 1 0 0 0 0 1 0)
    '(0 0 1 0 0 1 0 0)
    '(0 0 0 1 1 0 0 0)
  ))

  (let 'adjacent-points
    (lambda '(point)
      '(sequence
        (let 'x (nth point 1))
        (let 'y (nth point 2))
        (list
          (list (sub x 1) (sub y 1))
          (list (sub x 1) y)
          (list (sub x 1) (add y 1))
          (list x (sub y 1))
          (list x (add y 1))
          (list (add x 1) (sub y 1))
          (list (add x 1) y)
          (list (add x 1) (add y 1))
        )
      )
    )
  )

  (let 'get-cell
    (lambda '(grid point)
      '(sequence
        (let 'x (nth point 1))
        (let 'y (nth point 2))
        (if (and
            (and (gt x 0) (le x (length grid)))
            (and (gt y 0) (le y (length (nth grid 1)))))
          '(nth (nth grid x) y)
          '0
        )
      )
    )
  )

  (let 'get-neighbors
    (lambda '(grid point)
      '(map
        (adjacent-points point)
        (lambda '(point)
          '(get-cell grid point)
        )
      )
    )
  )

  (let 'compute-new-value
    (lambda '(grid point)
      '(sequence
        (let 'living-neighbors (sum (get-neighbors grid point)))
        (if (eq 1 (get-cell grid point))
          '(if (or (eq living-neighbors 2) (eq living-neighbors 3))
            '1
            '0
          )
          '(if (eq living-neighbors 3)
            '1
            '0
          )
        )
      )
    )
  )

  (let 'next-generation
    (lambda '(grid)
      '(sequence
        (let 'rows (length grid))
        (let 'cols (length (head grid)))
        (map
          (range rows)
          (lambda '(row)
            '(map
              (range cols)
              (lambda '(col)
                '(compute-new-value grid (list row col))
              )
            )
          )
        )
      )
    )
  )

  (let 'print-grid
    (lambda '(grid)
      '(sequence
        (let 'rows (length grid))
        (map
          (range rows)
          (lambda '(row)
            '(print (nth grid row))
          )
        )
      )
    )
  )

  (let 'generations
    (lambda '(grid count)
      '(if (eq 0 count)
        'done
        '(sequence
          (print-grid grid)
          (print '())
          (generations (next-generation grid) (sub count 1))
        )
      )
    )
  )

  (generations pattern 6)

)
