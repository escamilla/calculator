(sequence

  (let true 0)

  (let false 1)

  (let not
    (lambda '(x)
      '(if x
        false
        true
      )
    )
  )

  (let and
    (lambda '(x y)
      '(if x
        y
        false
      )
    )
  )

  (let or
    (lambda '(x y)
      '(if x
        true
        y
      )
    )
  )

  (let le
    (lambda '(x y)
      '(or (lt x y) (eq x y))
    )
  )

  (let ge
    (lambda '(x y)
      '(or (gt x y) (eq x y))
    )
  )

  (let factorial
    (lambda '(x)
      '(if (eq x 0)
        1
        (mul x (factorial (sub x 1)))
      )
    )
  )

  (let is-even
    (lambda '(x) '(eq 0 (mod x 2)))
  )

  (let is-odd
    (lambda '(x) '(eq 1 (mod x 2)))
  )

  (let square
    (lambda '(x) '(mul x x))
  )

  (let is-empty
    (lambda '(array)
      '(eq 0 (length array))
    )
  )

  (let head
    (lambda '(array)
      '(nth array 1)
    )
  )

  (let tail
    (lambda '(array)
      '(slice array 1 (add (length array) 1))
    )
  )

  (let range
    (lambda '(x)
      '(if (le x 0)
        '()
        (concat
          (range (sub x 1))
          (list x)
        )
      )
    )
  )

  (let map
    (lambda '(array function)
      '(if (is-empty array)
        '()
        (concat
          (list (function (head array)))
          (map (tail array) function)
        )
      )
    )
  )

  (let filter
    (lambda '(array function)
      '(if (is-empty array)
        '()
        (concat
          (if (function (head array))
            (list (head array))
            '()
          )
          (filter (tail array) function)
        )
      )
    )
  )

  (let some
    (lambda '(array function)
      '(if (is-empty array)
        false
        (if (function (head array))
          true
          (some (tail array) function)
        )
      )
    )
  )

  (let every
    (lambda '(array function)
      '(eq
        (length array)
        (length (filter array function))
      )
    )
  )

  (let reduce
    (lambda '(array function accumulator)
      '(if (is-empty array)
        accumulator
        (reduce (tail array) function (function accumulator (head array)))
      )
    )
  )

  (let sum
    (lambda '(array)
      '(reduce array add 0)
    )
  )

  (let product
    (lambda '(array)
      '(reduce array mul 1)
    )
  )

  (let includes
    (lambda '(array value)
      '(if (is-empty array)
        false
        (if (eq (head array) value)
          true
          (includes (tail array) value)
        )
      )
    )
  )

  (let reverse
    (lambda '(array)
      '(if (is-empty array)
        '()
        (concat
          (reverse (tail array))
          (list (head array))
        )
      )
    )
  )

  (let find
    (lambda '(array function)
      '(if (is-empty array)
        '()
        (sequence
          (let value (head array))
          (if (function value)
            value
            (find (tail array) function)
          )
        )
      )
    )
  )

  (let pattern '(
    (0 0 0 1 1 0 0 0)
    (0 0 1 0 0 1 0 0)
    (0 1 0 0 0 0 1 0)
    (1 0 0 0 0 0 0 1)
    (1 0 0 0 0 0 0 1)
    (0 1 0 0 0 0 1 0)
    (0 0 1 0 0 1 0 0)
    (0 0 0 1 1 0 0 0)
  ))

  (let adjacent-points
    (lambda '(point)
      '(sequence
        (let x (nth point 1))
        (let y (nth point 2))
        (list
          (list (sub x 1) (sub y 1))
          (list (sub x 1) y)
          (list (sub x 1) (add y 1))
          (list x (sub y 1))
          (list x (add y 1))
          (list (add x 1) (sub y 1))
          (list (add x 1) y)
          (list (add x 1) (add y 1))
        )
      )
    )
  )

  (let get-cell
    (lambda '(grid point)
      '(sequence
        (let x (nth point 1))
        (let y (nth point 2))
        (if (and
            (and (gt x 0) (le x (length grid)))
            (and (gt y 0) (le y (length (nth grid 1)))))
          (nth (nth grid x) y)
          0
        )
      )
    )
  )

  (let get-neighbors
    (lambda '(grid point)
      '(map
        (adjacent-points point)
        (lambda '(point)
          '(get-cell grid point)
        )
      )
    )
  )

  (let compute-new-value
    (lambda '(grid point)
      '(sequence
        (let living-neighbors (sum (get-neighbors grid point)))
        (if (eq 1 (get-cell grid point))
          (if (or (eq living-neighbors 2) (eq living-neighbors 3))
            1
            0
          )
          (if (eq living-neighbors 3)
            1
            0
          )
        )
      )
    )
  )

  (let next-generation
    (lambda '(grid)
      '(sequence
        (let rows (length grid))
        (let cols (length (head grid)))
        (map
          (range rows)
          (lambda '(row)
            '(map
              (range cols)
              (lambda '(col)
                '(compute-new-value grid (list row col))
              )
            )
          )
        )
      )
    )
  )

  (let print-grid
    (lambda '(grid)
      '(sequence
        (let rows (length grid))
        (map
          (range rows)
          (lambda '(row)
            '(print (nth grid row))
          )
        )
      )
    )
  )

  (let generations
    (lambda '(grid count)
      '(if (eq 0 count)
        done
        (sequence
          (print-grid grid)
          (print '())
          (generations (next-generation grid) (sub count 1))
        )
      )
    )
  )

  (generations pattern 11)

  done

)
